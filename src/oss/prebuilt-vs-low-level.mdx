import V1Alpha from '/snippets/v1-alpha.mdx';

<V1Alpha />

---
title: Prebuilt components vs. low-level primitives
sidebarTitle: Prebuilt vs. low-level
--- 

import prebuiltsTable from '/snippets/prebuilts-table-python.mdx';
import prebuiltsTableJS from '/snippets/prebuilts-table-js.mdx';

LangGraph provides two distinct approaches for building AI agent workflows, each designed for different use cases and development preferences. Understanding when to use each approach will help you choose the right path for your project.

## Prebuilt agents

LangGraph comes with a set of [prebuilt components](/oss/prebuilts) that implement common agent behaviors and architectures. These abstractions are built on top of the LangGraph framework, offering a faster path to production. These components encapsulate complex orchestration logic into simple, configurable interfaces.

### Available prebuilts

:::python
<prebuiltsTable/>
:::

:::js
<prebuiltsTableJS/>
:::

### Key benefits

There are several key benefits to using prebuilt agents:

- **Rapid development**: Deploy working agents in minutes, not hours
- **Built-in best practices**: Incorporates proven patterns for reliability and performance
- **Reduced complexity**: Abstracts away low-level graph construction details

### Use cases

- Prototyping and proof-of-concepts
- Standard agent workflows (e.g.,Q&A, tool usage, basic reasoning)
- Teams prioritizing speed-to-market
- Applications with well-defined, common patterns

Starting with prebuilt components is a good way to get started with LangGraph. If you need more control or customization, you can use low-level orchestration.

## Low-level orchestration

[Low-level orchestration](/oss/why-langgraph) provides complete control over agent behavior through custom graph construction. You define the exact flow, state management, and decision logic for your agent or workflow.

### Core components

- **StateGraph**: Define custom state schemas tailored to your use case.
- **Nodes**: Implement custom processing functions with full control over execution.
- **Edges**: Configure precise transitions and routing between processing steps.
- **Conditional logic**: Create dynamic workflows that adapt based on runtime conditions.
- **Human-in-the-loop**: Integrate approval steps and manual interventions seamlessly.

For more information, see [Graph API](/oss/graph-api).

### Key benefits

- **Maximum flexibility**: Build agents that match your exact requirements.
- **Custom state management**: Track complex data structures and business context.
- **Advanced routing**: Implement sophisticated decision trees and parallel processing.
- **System integration**: Connect seamlessly with existing tools, databases, and APIs.
- **Performance optimization**: Fine-tune execution for specific workloads.

### Use cases

- Complex business workflows with unique requirements
- Multi-step processes requiring custom state tracking
- Integration with proprietary systems and APIs
- Performance-critical applications requiring optimization
- Agents with sophisticated decision-making logic